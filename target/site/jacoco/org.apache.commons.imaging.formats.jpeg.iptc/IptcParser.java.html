<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IptcParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Imaging</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.imaging.formats.jpeg.iptc</a> &gt; <span class="el_source">IptcParser.java</span></div><h1>IptcParser.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.imaging.formats.jpeg.iptc;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.imaging.ImagingConstants;
import org.apache.commons.imaging.ImagingException;
import org.apache.commons.imaging.ImagingParameters;
import org.apache.commons.imaging.common.Allocator;
import org.apache.commons.imaging.common.BinaryFileParser;
import org.apache.commons.imaging.common.BinaryFunctions;
import org.apache.commons.imaging.common.BinaryOutputStream;
import org.apache.commons.imaging.common.ByteConversions;
import org.apache.commons.imaging.formats.jpeg.JpegConstants;
import org.apache.commons.imaging.formats.jpeg.JpegImagingParameters;
import org.apache.commons.imaging.internal.Debug;

public class IptcParser extends BinaryFileParser {

<span class="fc" id="L49">    private static final Logger LOGGER = Logger.getLogger(IptcParser.class.getName());</span>

<span class="fc" id="L51">    private static final ByteOrder APP13_BYTE_ORDER = ByteOrder.BIG_ENDIAN;</span>

    /**
     * Block types (or Image Resource IDs) that are not recommended to be interpreted when libraries process Photoshop IPTC metadata.
     *
     * @see &lt;a href=&quot;https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/&quot;&gt;Adobe Photoshop File Formats Specification&lt;/a&gt;
     * @see &lt;a href=&quot;https://issues.apache.org/jira/browse/IMAGING-246&quot;&gt;IMAGING-246&lt;/a&gt;
     * @since 1.0-alpha2
     */
<span class="fc" id="L60">    private static final List&lt;Integer&gt; PHOTOSHOP_IGNORED_BLOCK_TYPE = Arrays.asList(1084, 1085, 1086, 1087);</span>

<span class="fc" id="L62">    private static final Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;</span>
    private static final int ENV_TAG_CODED_CHARACTER_SET = 90;
<span class="fc" id="L64">    private static final byte[] CHARACTER_ESCAPE_SEQUENCE = { '\u001B', '%', 'G' };</span>

    public IptcParser() {
<span class="fc" id="L67">        super(ByteOrder.BIG_ENDIAN);</span>
<span class="fc" id="L68">    }</span>

    private Charset findCharset(final byte[] codedCharset) {
<span class="fc" id="L71">        final String codedCharsetString = new String(codedCharset, StandardCharsets.ISO_8859_1);</span>
        try {
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (Charset.isSupported(codedCharsetString)) {</span>
<span class="nc" id="L74">                return Charset.forName(codedCharsetString);</span>
            }
<span class="fc" id="L76">        } catch (final IllegalArgumentException ignored) {</span>
            // ignored
<span class="nc" id="L78">        }</span>
        // check if encoding is a escape sequence
        // normalize encoding byte sequence
<span class="fc" id="L81">        final byte[] codedCharsetNormalized = Allocator.byteArray(codedCharset.length);</span>
<span class="fc" id="L82">        int j = 0;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (final byte element : codedCharset) {</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if (element != ' ') {</span>
<span class="fc" id="L85">                codedCharsetNormalized[j++] = element;</span>
            }
        }

<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (Objects.deepEquals(codedCharsetNormalized, CHARACTER_ESCAPE_SEQUENCE)) {</span>
<span class="fc" id="L90">            return StandardCharsets.UTF_8;</span>
        }
<span class="nc" id="L92">        return DEFAULT_CHARSET;</span>
    }

    public boolean isPhotoshopJpegSegment(final byte[] segmentData) {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (!BinaryFunctions.startsWith(segmentData, JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING)) {</span>
<span class="nc" id="L97">            return false;</span>
        }

<span class="fc" id="L100">        final int index = JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.size();</span>
<span class="fc bfc" id="L101" title="All 4 branches covered.">        return index + 4 &lt;= segmentData.length &amp;&amp; ByteConversions.toInt(segmentData, index, APP13_BYTE_ORDER) == JpegConstants.CONST_8BIM;</span>
    }

    protected List&lt;IptcBlock&gt; parseAllBlocks(final byte[] bytes, final boolean strict) throws ImagingException, IOException {
<span class="fc" id="L105">        final List&lt;IptcBlock&gt; blocks = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L107">        try (InputStream bis = new ByteArrayInputStream(bytes)) {</span>

            // Note that these are unsigned quantities. Name is always an even
            // number of bytes (including the 1st byte, which is the size.)

<span class="fc" id="L112">            final byte[] idString = BinaryFunctions.readBytes(&quot;&quot;, bis, JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.size(),</span>
                    &quot;App13 Segment missing identification string&quot;);
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">            if (!JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.equals(idString)) {</span>
<span class="nc" id="L115">                throw new ImagingException(&quot;Not a Photoshop App13 Segment&quot;);</span>
            }

            // int index = PHOTOSHOP_IDENTIFICATION_STRING.length;

            while (true) {
                final int imageResourceBlockSignature;
                try {
<span class="fc" id="L123">                    imageResourceBlockSignature = BinaryFunctions.read4Bytes(&quot;&quot;, bis, &quot;Image Resource Block missing identification string&quot;, APP13_BYTE_ORDER);</span>
<span class="fc" id="L124">                } catch (final IOException ioEx) {</span>
<span class="fc" id="L125">                    break;</span>
<span class="fc" id="L126">                }</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                if (imageResourceBlockSignature != JpegConstants.CONST_8BIM) {</span>
<span class="nc" id="L128">                    throw new ImagingException(&quot;Invalid Image Resource Block Signature&quot;);</span>
                }

<span class="fc" id="L131">                final int blockType = BinaryFunctions.read2Bytes(&quot;&quot;, bis, &quot;Image Resource Block missing type&quot;, APP13_BYTE_ORDER);</span>
<span class="fc" id="L132">                Debug.debug(&quot;blockType: &quot; + blockType + &quot; (0x&quot; + Integer.toHexString(blockType) + &quot;)&quot;);</span>

                // skip blocks that the photoshop spec recommends to, see IMAGING-246
<span class="fc bfc" id="L135" title="All 2 branches covered.">                if (PHOTOSHOP_IGNORED_BLOCK_TYPE.contains(blockType)) {</span>
<span class="fc" id="L136">                    Debug.debug(&quot;Skipping blockType: &quot; + blockType + &quot; (0x&quot; + Integer.toHexString(blockType) + &quot;)&quot;);</span>
                    // if there is still data in this block, before the next image resource block
                    // (8BIM), then we must consume these bytes to leave a pointer ready to read
                    // the next block
<span class="fc" id="L140">                    BinaryFunctions.searchQuad(JpegConstants.CONST_8BIM, bis);</span>
<span class="fc" id="L141">                    continue;</span>
                }

<span class="fc" id="L144">                final int blockNameLength = BinaryFunctions.readByte(&quot;Name length&quot;, bis, &quot;Image Resource Block missing name length&quot;);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                if (blockNameLength &gt; 0) {</span>
<span class="nc" id="L146">                    Debug.debug(&quot;blockNameLength: &quot; + blockNameLength + &quot; (0x&quot; + Integer.toHexString(blockNameLength) + &quot;)&quot;);</span>
                }
                byte[] blockNameBytes;
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">                if (blockNameLength == 0) {</span>
<span class="fc" id="L150">                    BinaryFunctions.readByte(&quot;Block name bytes&quot;, bis, &quot;Image Resource Block has invalid name&quot;);</span>
<span class="fc" id="L151">                    blockNameBytes = ImagingConstants.EMPTY_BYTE_ARRAY;</span>
                } else {
                    try {
<span class="nc" id="L154">                        blockNameBytes = BinaryFunctions.readBytes(&quot;&quot;, bis, blockNameLength, &quot;Invalid Image Resource Block name&quot;);</span>
<span class="nc" id="L155">                    } catch (final IOException ioEx) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                        if (strict) {</span>
<span class="nc" id="L157">                            throw ioEx;</span>
                        }
<span class="nc" id="L159">                        break;</span>
<span class="nc" id="L160">                    }</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (blockNameLength % 2 == 0) {</span>
<span class="nc" id="L163">                        BinaryFunctions.readByte(&quot;Padding byte&quot;, bis, &quot;Image Resource Block missing padding byte&quot;);</span>
                    }
                }

<span class="fc" id="L167">                final int blockSize = BinaryFunctions.read4Bytes(&quot;&quot;, bis, &quot;Image Resource Block missing size&quot;, APP13_BYTE_ORDER);</span>
<span class="fc" id="L168">                Debug.debug(&quot;blockSize: &quot; + blockSize + &quot; (0x&quot; + Integer.toHexString(blockSize) + &quot;)&quot;);</span>

                /*
                 * doesn't catch cases where blocksize is invalid but is still less than bytes.length but will at least prevent OutOfMemory errors
                 */
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (blockSize &gt; bytes.length) {</span>
<span class="nc" id="L174">                    throw new ImagingException(&quot;Invalid Block Size : &quot; + blockSize + &quot; &gt; &quot; + bytes.length);</span>
                }

                final byte[] blockData;
                try {
<span class="fc" id="L179">                    blockData = BinaryFunctions.readBytes(&quot;&quot;, bis, blockSize, &quot;Invalid Image Resource Block data&quot;);</span>
<span class="nc" id="L180">                } catch (final IOException ioEx) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                    if (strict) {</span>
<span class="nc" id="L182">                        throw ioEx;</span>
                    }
<span class="nc" id="L184">                    break;</span>
<span class="fc" id="L185">                }</span>

<span class="fc" id="L187">                blocks.add(new IptcBlock(blockType, blockNameBytes, blockData));</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">                if (blockSize % 2 != 0) {</span>
<span class="fc" id="L190">                    BinaryFunctions.readByte(&quot;Padding byte&quot;, bis, &quot;Image Resource Block missing padding byte&quot;);</span>
                }
<span class="fc" id="L192">            }</span>

<span class="fc" id="L194">            return blocks;</span>
        }
    }

    protected List&lt;IptcRecord&gt; parseIptcBlock(final byte[] bytes) {
<span class="fc" id="L199">        Charset charset = DEFAULT_CHARSET;</span>
<span class="fc" id="L200">        final List&lt;IptcRecord&gt; elements = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L202">        int index = 0;</span>
        // Integer recordVersion = null;
<span class="fc bfc" id="L204" title="All 2 branches covered.">        while (index + 1 &lt; bytes.length) {</span>
<span class="fc" id="L205">            final int tagMarker = 0xff &amp; bytes[index++];</span>
<span class="fc" id="L206">            Debug.debug(&quot;tagMarker: &quot; + tagMarker + &quot; (0x&quot; + Integer.toHexString(tagMarker) + &quot;)&quot;);</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            if (tagMarker != IptcConstants.IPTC_RECORD_TAG_MARKER) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (LOGGER.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L210">                    LOGGER.fine(&quot;Unexpected record tag marker in IPTC data.&quot;);</span>
                }
<span class="nc" id="L212">                return elements;</span>
            }

<span class="fc" id="L215">            final int recordNumber = 0xff &amp; bytes[index++];</span>
<span class="fc" id="L216">            Debug.debug(&quot;recordNumber: &quot; + recordNumber + &quot; (0x&quot; + Integer.toHexString(recordNumber) + &quot;)&quot;);</span>

            // int recordPrefix = convertByteArrayToShort(&quot;recordPrefix&quot;, index,
            // bytes);
            // if (verbose)
            // Debug.debug(&quot;recordPrefix&quot;, recordPrefix + &quot; (0x&quot;
            // + Integer.toHexString(recordPrefix) + &quot;)&quot;);
            // index += 2;
            //
            // if (recordPrefix != IPTC_RECORD_PREFIX)
            // {
            // if (verbose)
            // System.out
            // .println(&quot;Unexpected record prefix in IPTC data!&quot;);
            // return elements;
            // }

            // throw new ImageReadException(
            // &quot;Unexpected record prefix in IPTC data.&quot;);

<span class="fc" id="L236">            final int recordType = 0xff &amp; bytes[index];</span>
<span class="fc" id="L237">            Debug.debug(&quot;recordType: &quot; + recordType + &quot; (0x&quot; + Integer.toHexString(recordType) + &quot;)&quot;);</span>
<span class="fc" id="L238">            index++;</span>

<span class="fc" id="L240">            final int recordSize = ByteConversions.toUInt16(bytes, index, getByteOrder());</span>
<span class="fc" id="L241">            index += 2;</span>

<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            final boolean extendedDataset = recordSize &gt; IptcConstants.IPTC_NON_EXTENDED_RECORD_MAXIMUM_SIZE;</span>
<span class="fc" id="L244">            final int dataFieldCountLength = recordSize &amp; 0x7fff;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">            if (extendedDataset) {</span>
<span class="nc" id="L246">                Debug.debug(&quot;extendedDataset. dataFieldCountLength: &quot; + dataFieldCountLength);</span>
            }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (extendedDataset) {</span>
                // ignore extended dataset and everything after.
<span class="nc" id="L250">                return elements;</span>
            }

<span class="fc" id="L253">            final byte[] recordData = BinaryFunctions.slice(bytes, index, recordSize);</span>
<span class="fc" id="L254">            index += recordSize;</span>

            // Debug.debug(&quot;recordSize&quot;, recordSize + &quot; (0x&quot;
            // + Integer.toHexString(recordSize) + &quot;)&quot;);

<span class="fc bfc" id="L259" title="All 4 branches covered.">            if (recordNumber == IptcConstants.IPTC_ENVELOPE_RECORD_NUMBER &amp;&amp; recordType == ENV_TAG_CODED_CHARACTER_SET) {</span>
<span class="fc" id="L260">                charset = findCharset(recordData);</span>
<span class="fc" id="L261">                continue;</span>
            }

<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (recordNumber != IptcConstants.IPTC_APPLICATION_2_RECORD_NUMBER) {</span>
<span class="fc" id="L265">                continue;</span>
            }

<span class="fc bfc" id="L268" title="All 2 branches covered.">            if (recordType == 0) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">                if (LOGGER.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L270">                    LOGGER.fine(&quot;ignore record version record! &quot; + elements.size());</span>
                }
                // ignore &quot;record version&quot; record;
                continue;
            }
            // if (recordVersion == null)
            // {
            // // The first record in a JPEG/Photoshop IPTC block must be
            // // the record version.
            // if (recordType != 0)
            // throw new ImageReadException(&quot;Missing record version: &quot;
            // + recordType);
            // recordVersion = new Integer(convertByteArrayToShort(
            // &quot;recordNumber&quot;, recordData));
            //
            // if (recordSize != 2)
            // throw new ImageReadException(
            // &quot;Invalid record version record size: &quot; + recordSize);
            //
            // // JPEG/Photoshop IPTC metadata is always in Record version
            // // 2
            // if (recordVersion.intValue() != 2)
            // throw new ImageReadException(
            // &quot;Invalid IPTC record version: &quot; + recordVersion);
            //
            // // Debug.debug(&quot;recordVersion&quot;, recordVersion);
            // continue;
            // }

<span class="fc" id="L299">            final String value = new String(recordData, charset);</span>

<span class="fc" id="L301">            final IptcType iptcType = IptcTypeLookup.getIptcType(recordType);</span>

            // Debug.debug(&quot;iptcType&quot;, iptcType);
            // debugByteArray(&quot;iptcData&quot;, iptcData);
            // Debug.debug();

            // if (recordType == IPTC_TYPE_CREDIT.type
            // || recordType == IPTC_TYPE_OBJECT_NAME.type)
            // {
            // this.debugByteArray(&quot;recordData&quot;, recordData);
            // Debug.debug(&quot;index&quot;, IPTC_TYPE_CREDIT.name);
            // }

<span class="fc" id="L314">            final IptcRecord element = new IptcRecord(iptcType, value);</span>
<span class="fc" id="L315">            elements.add(element);</span>
<span class="fc" id="L316">        }</span>

<span class="fc" id="L318">        return elements;</span>
    }

    public PhotoshopApp13Data parsePhotoshopSegment(final byte[] bytes, final boolean strict) throws ImagingException, IOException {
<span class="fc" id="L322">        final List&lt;IptcRecord&gt; records = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L324">        final List&lt;IptcBlock&gt; blocks = parseAllBlocks(bytes, strict);</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (final IptcBlock block : blocks) {</span>
            // Ignore everything but IPTC data.
<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (!block.isIptcBlock()) {</span>
<span class="fc" id="L329">                continue;</span>
            }

<span class="fc" id="L332">            records.addAll(parseIptcBlock(block.getBlockData()));</span>
<span class="fc" id="L333">        }</span>

<span class="fc" id="L335">        return new PhotoshopApp13Data(records, blocks);</span>
    }

    // private void writeIPTCRecord(BinaryOutputStream bos, )

    /*
     * In practice, App13 segments are only used for Photoshop/IPTC metadata. However, we should not treat App13 signatures without Photoshop's signature as
     * Photoshop/IPTC segments.
     *
     * A Photoshop/IPTC App13 segment begins with the Photoshop Identification string.
     *
     * There follows 0-N blocks (Photoshop calls them &quot;Image Resource Blocks&quot;).
     *
     * Each block has the following structure:
     *
     * 1. 4-byte type. This is always &quot;8BIM&quot; for blocks in a Photoshop App13 segment. 2. 2-byte id. IPTC data is stored in blocks with id 0x0404, aka.
     * IPTC_NAA_RECORD_IMAGE_RESOURCE_ID 3. Block name as a Pascal String. This is padded to have an even length. 4. 4-byte size (in bytes). 5. Block data. This
     * is also padded to have an even length.
     *
     * The block data consists of a 0-N records. A record has the following structure:
     *
     * 1. 2-byte prefix. The value is always 0x1C02 2. 1-byte record type. The record types are documented by the IPTC. See IptcConstants. 3. 2-byte record size
     * (in bytes). 4. Record data, &quot;record size&quot; bytes long.
     *
     * Record data (unlike block data) is NOT padded to have an even length.
     *
     * Record data, for IPTC record, should always be ISO-8859-1. But according to SANSELAN-33, this isn't always the case.
     *
     * The exception is the first record in the block, which must always be a record version record, whose value is a two-byte number; the value is 0x02.
     *
     * Some IPTC blocks are missing this first &quot;record version&quot; record, so we don't require it.
     */
    public PhotoshopApp13Data parsePhotoshopSegment(final byte[] bytes, final ImagingParameters&lt;JpegImagingParameters&gt; params)
            throws ImagingException, IOException {
<span class="pc bpc" id="L369" title="2 of 4 branches missed.">        final boolean strict = params != null &amp;&amp; params.isStrict();</span>

<span class="fc" id="L371">        return parsePhotoshopSegment(bytes, strict);</span>
    }

    public byte[] writeIptcBlock(List&lt;IptcRecord&gt; elements) throws ImagingException, IOException {
<span class="fc" id="L375">        Charset charset = DEFAULT_CHARSET;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (final IptcRecord element : elements) {</span>
<span class="fc" id="L377">            final byte[] recordData = element.getValue().getBytes(charset);</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (!new String(recordData, charset).equals(element.getValue())) {</span>
<span class="nc" id="L379">                charset = StandardCharsets.UTF_8;</span>
<span class="nc" id="L380">                break;</span>
            }
<span class="fc" id="L382">        }</span>
<span class="fc" id="L383">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L384">        try (BinaryOutputStream bos = BinaryOutputStream.create(baos, getByteOrder())) {</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (!charset.equals(DEFAULT_CHARSET)) {</span>
<span class="nc" id="L386">                bos.write(IptcConstants.IPTC_RECORD_TAG_MARKER);</span>
<span class="nc" id="L387">                bos.write(IptcConstants.IPTC_ENVELOPE_RECORD_NUMBER);</span>
<span class="nc" id="L388">                bos.write(ENV_TAG_CODED_CHARACTER_SET);</span>
<span class="nc" id="L389">                final byte[] codedCharset = CHARACTER_ESCAPE_SEQUENCE;</span>
<span class="nc" id="L390">                bos.write2Bytes(codedCharset.length);</span>
<span class="nc" id="L391">                bos.write(codedCharset);</span>
            }

            // first, right record version record
<span class="fc" id="L395">            bos.write(IptcConstants.IPTC_RECORD_TAG_MARKER);</span>
<span class="fc" id="L396">            bos.write(IptcConstants.IPTC_APPLICATION_2_RECORD_NUMBER);</span>
<span class="fc" id="L397">            bos.write(IptcTypes.RECORD_VERSION.type); // record version record</span>
                                                      // type.
<span class="fc" id="L399">            bos.write2Bytes(2); // record version record size</span>
<span class="fc" id="L400">            bos.write2Bytes(2); // record version value</span>

            // make a copy of the list.
<span class="fc" id="L403">            elements = new ArrayList&lt;&gt;(elements);</span>

            // sort the list. Records must be in numerical order.
<span class="fc" id="L406">            final Comparator&lt;IptcRecord&gt; comparator = (e1, e2) -&gt; e2.iptcType.getType() - e1.iptcType.getType();</span>
<span class="fc" id="L407">            elements.sort(comparator);</span>
            // TODO: make sure order right

            // write the list.
<span class="fc bfc" id="L411" title="All 2 branches covered.">            for (final IptcRecord element : elements) {</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">                if (element.iptcType == IptcTypes.RECORD_VERSION) {</span>
<span class="nc" id="L413">                    continue; // ignore</span>
                }

<span class="fc" id="L416">                bos.write(IptcConstants.IPTC_RECORD_TAG_MARKER);</span>
<span class="fc" id="L417">                bos.write(IptcConstants.IPTC_APPLICATION_2_RECORD_NUMBER);</span>
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">                if (element.iptcType.getType() &lt; 0 || element.iptcType.getType() &gt; 0xff) {</span>
<span class="nc" id="L419">                    throw new ImagingException(&quot;Invalid record type: &quot; + element.iptcType.getType());</span>
                }
<span class="fc" id="L421">                bos.write(element.iptcType.getType());</span>

<span class="fc" id="L423">                final byte[] recordData = element.getValue().getBytes(charset);</span>
                /*
                 * if (!new String(recordData, charset).equals(element.getValue())) { throw new ImageWriteException( &quot;Invalid record value, not &quot; +
                 * charset.name()); }
                 */

<span class="fc" id="L429">                bos.write2Bytes(recordData.length);</span>
<span class="fc" id="L430">                bos.write(recordData);</span>
<span class="fc" id="L431">            }</span>
        }

<span class="fc" id="L434">        return baos.toByteArray();</span>
    }

    public byte[] writePhotoshopApp13Segment(final PhotoshopApp13Data data) throws IOException, ImagingException {
<span class="fc" id="L438">        try (ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span class="fc" id="L439">                BinaryOutputStream bos = BinaryOutputStream.bigEndian(os)) {</span>

<span class="fc" id="L441">            JpegConstants.PHOTOSHOP_IDENTIFICATION_STRING.writeTo(bos);</span>

<span class="fc" id="L443">            final List&lt;IptcBlock&gt; blocks = data.getRawBlocks();</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">            for (final IptcBlock block : blocks) {</span>
<span class="fc" id="L445">                bos.write4Bytes(JpegConstants.CONST_8BIM);</span>

<span class="pc bpc" id="L447" title="2 of 4 branches missed.">                if (block.getBlockType() &lt; 0 || block.getBlockType() &gt; 0xffff) {</span>
<span class="nc" id="L448">                    throw new ImagingException(&quot;Invalid IPTC block type.&quot;);</span>
                }
<span class="fc" id="L450">                bos.write2Bytes(block.getBlockType());</span>

<span class="fc" id="L452">                final byte[] blockNameBytes = block.getBlockNameBytes();</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                if (blockNameBytes.length &gt; 255) {</span>
<span class="nc" id="L454">                    throw new ImagingException(&quot;IPTC block name is too long: &quot; + blockNameBytes.length);</span>
                }
<span class="fc" id="L456">                bos.write(blockNameBytes.length);</span>
<span class="fc" id="L457">                bos.write(blockNameBytes);</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                if (blockNameBytes.length % 2 == 0) {</span>
<span class="fc" id="L459">                    bos.write(0); // pad to even size, including length byte.</span>
                }

<span class="fc" id="L462">                final byte[] blockData = block.getBlockData();</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                if (blockData.length &gt; IptcConstants.IPTC_NON_EXTENDED_RECORD_MAXIMUM_SIZE) {</span>
<span class="nc" id="L464">                    throw new ImagingException(&quot;IPTC block data is too long: &quot; + blockData.length);</span>
                }
<span class="fc" id="L466">                bos.write4Bytes(blockData.length);</span>
<span class="fc" id="L467">                bos.write(blockData);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                if (blockData.length % 2 == 1) {</span>
<span class="fc" id="L469">                    bos.write(0); // pad to even size</span>
                }
<span class="fc" id="L471">            }</span>

<span class="fc" id="L473">            bos.flush();</span>
<span class="fc" id="L474">            return os.toByteArray();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>