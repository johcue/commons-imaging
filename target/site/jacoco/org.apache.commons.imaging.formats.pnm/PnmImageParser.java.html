<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PnmImageParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Imaging</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.imaging.formats.pnm</a> &gt; <span class="el_source">PnmImageParser.java</span></div><h1>PnmImageParser.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.imaging.formats.pnm;

import static org.apache.commons.imaging.common.BinaryFunctions.readByte;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.stream.Stream;

import org.apache.commons.imaging.AbstractImageParser;
import org.apache.commons.imaging.ImageFormat;
import org.apache.commons.imaging.ImageFormats;
import org.apache.commons.imaging.ImageInfo;
import org.apache.commons.imaging.ImagingException;
import org.apache.commons.imaging.bytesource.ByteSource;
import org.apache.commons.imaging.common.ImageBuilder;
import org.apache.commons.imaging.common.ImageMetadata;
import org.apache.commons.imaging.palette.PaletteFactory;

public class PnmImageParser extends AbstractImageParser&lt;PnmImagingParameters&gt; {

    private static final String TOKEN_ENDHDR = &quot;ENDHDR&quot;;
    private static final String TOKEN_TUPLTYPE = &quot;TUPLTYPE&quot;;
    private static final String TOKEN_MAXVAL = &quot;MAXVAL&quot;;
    private static final String TOKEN_DEPTH = &quot;DEPTH&quot;;
    private static final String TOKEN_HEIGHT = &quot;HEIGHT&quot;;
    private static final String TOKEN_WIDTH = &quot;WIDTH&quot;;

    private static final int DPI = 72;
    private static final ImageFormat[] IMAGE_FORMATS;
<span class="fc" id="L54">    private static final String DEFAULT_EXTENSION = ImageFormats.PNM.getDefaultExtension();</span>
    private static final String[] ACCEPTED_EXTENSIONS;

    static {
<span class="fc" id="L58">        IMAGE_FORMATS = new ImageFormat[] {</span>
                // @formatter:off
                ImageFormats.PAM,
                ImageFormats.PBM,
                ImageFormats.PGM,
                ImageFormats.PNM,
                ImageFormats.PPM
                // @formatter:on
        };
<span class="fc" id="L67">        ACCEPTED_EXTENSIONS = Stream.of(IMAGE_FORMATS).map(ImageFormat::getDefaultExtension).toArray(String[]::new);</span>
<span class="fc" id="L68">    }</span>

    public PnmImageParser() {
<span class="fc" id="L71">        super(ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc" id="L72">    }</span>

    private void check(final boolean value, final String type) throws ImagingException {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (!value) {</span>
<span class="fc" id="L76">            throw new ImagingException(&quot;PAM header has no &quot; + type + &quot; value&quot;);</span>
        }
<span class="fc" id="L78">    }</span>

    private void checkFound(final int value, final String type) throws ImagingException {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        check(value != -1, type);</span>
<span class="fc" id="L82">    }</span>

    private String checkNextTokens(final StringTokenizer tokenizer, final String type) throws ImagingException {
<span class="fc" id="L85">        check(tokenizer.hasMoreTokens(), type);</span>
<span class="fc" id="L86">        return tokenizer.nextToken();</span>
    }

    private int checkNextTokensAsInt(final StringTokenizer tokenizer, final String type) throws ImagingException {
<span class="fc" id="L90">        return Integer.parseInt(checkNextTokens(tokenizer, type));</span>
    }

    @Override
    public boolean dumpImageFile(final PrintWriter pw, final ByteSource byteSource) throws ImagingException, IOException {
<span class="nc" id="L95">        pw.println(&quot;pnm.dumpImageFile&quot;);</span>

<span class="nc" id="L97">        final ImageInfo imageData = getImageInfo(byteSource);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (imageData == null) {</span>
<span class="nc" id="L99">            return false;</span>
        }

<span class="nc" id="L102">        imageData.toString(pw, &quot;&quot;);</span>

<span class="nc" id="L104">        pw.println(&quot;&quot;);</span>

<span class="nc" id="L106">        return true;</span>
    }

    @Override
    protected String[] getAcceptedExtensions() {
<span class="fc" id="L111">        return ACCEPTED_EXTENSIONS.clone();</span>
    }

    @Override
    protected ImageFormat[] getAcceptedTypes() {
<span class="fc" id="L116">        return IMAGE_FORMATS.clone();</span>
    }

    @Override
    public BufferedImage getBufferedImage(final ByteSource byteSource, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L121">        try (InputStream is = byteSource.getInputStream()) {</span>
<span class="fc" id="L122">            final AbstractFileInfo info = readHeader(is);</span>

<span class="fc" id="L124">            final int width = info.width;</span>
<span class="fc" id="L125">            final int height = info.height;</span>

<span class="fc" id="L127">            final boolean hasAlpha = info.hasAlpha();</span>
<span class="fc" id="L128">            final ImageBuilder imageBuilder = new ImageBuilder(width, height, hasAlpha);</span>
<span class="fc" id="L129">            info.readImage(imageBuilder, is);</span>

<span class="fc" id="L131">            return imageBuilder.getBufferedImage();</span>
        }
    }

    @Override
    public String getDefaultExtension() {
<span class="nc" id="L137">        return DEFAULT_EXTENSION;</span>
    }

    @Override
    public PnmImagingParameters getDefaultParameters() {
<span class="fc" id="L142">        return new PnmImagingParameters();</span>
    }

    @Override
    public byte[] getIccProfileBytes(final ByteSource byteSource, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L147">        return null;</span>
    }

    @Override
    public ImageInfo getImageInfo(final ByteSource byteSource, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L152">        final AbstractFileInfo info = readHeader(byteSource);</span>

<span class="fc" id="L154">        final List&lt;String&gt; comments = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L156">        final int bitsPerPixel = info.getBitDepth() * info.getNumComponents();</span>
<span class="fc" id="L157">        final ImageFormat format = info.getImageType();</span>
<span class="fc" id="L158">        final String formatName = info.getImageTypeDescription();</span>
<span class="fc" id="L159">        final String mimeType = info.getMimeType();</span>
<span class="fc" id="L160">        final int numberOfImages = 1;</span>
<span class="fc" id="L161">        final boolean progressive = false;</span>

        // boolean progressive = (fPNGChunkIHDR.InterlaceMethod != 0);
        //
<span class="fc" id="L165">        final int physicalWidthDpi = DPI;</span>
<span class="fc" id="L166">        final float physicalWidthInch = (float) ((double) info.width / (double) physicalWidthDpi);</span>
<span class="fc" id="L167">        final int physicalHeightDpi = DPI;</span>
<span class="fc" id="L168">        final float physicalHeightInch = (float) ((double) info.height / (double) physicalHeightDpi);</span>

<span class="fc" id="L170">        final String formatDetails = info.getImageTypeDescription();</span>

<span class="fc" id="L172">        final boolean transparent = info.hasAlpha();</span>
<span class="fc" id="L173">        final boolean usesPalette = false;</span>

<span class="fc" id="L175">        final ImageInfo.ColorType colorType = info.getColorType();</span>
<span class="fc" id="L176">        final ImageInfo.CompressionAlgorithm compressionAlgorithm = ImageInfo.CompressionAlgorithm.NONE;</span>

<span class="fc" id="L178">        return new ImageInfo(formatDetails, bitsPerPixel, comments, format, formatName, info.height, mimeType, numberOfImages, physicalHeightDpi,</span>
                physicalHeightInch, physicalWidthDpi, physicalWidthInch, info.width, progressive, transparent, usesPalette, colorType, compressionAlgorithm);
    }

    @Override
    public Dimension getImageSize(final ByteSource byteSource, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L184">        final AbstractFileInfo info = readHeader(byteSource);</span>
<span class="fc" id="L185">        return new Dimension(info.width, info.height);</span>
    }

    @Override
    public ImageMetadata getMetadata(final ByteSource byteSource, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L190">        return null;</span>
    }

    @Override
    public String getName() {
<span class="nc" id="L195">        return &quot;Pbm-Custom&quot;;</span>
    }

    private AbstractFileInfo readHeader(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L199">        try (InputStream is = byteSource.getInputStream()) {</span>
<span class="fc" id="L200">            return readHeader(is);</span>
        }
    }

    private AbstractFileInfo readHeader(final InputStream inputStream) throws ImagingException, IOException {
<span class="fc" id="L205">        final byte identifier1 = readByte(&quot;Identifier1&quot;, inputStream, &quot;Not a Valid PNM File&quot;);</span>
<span class="fc" id="L206">        final byte identifier2 = readByte(&quot;Identifier2&quot;, inputStream, &quot;Not a Valid PNM File&quot;);</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (identifier1 != PnmConstants.PNM_PREFIX_BYTE) {</span>
<span class="nc" id="L209">            throw new ImagingException(&quot;PNM file has invalid prefix byte 1&quot;);</span>
        }

<span class="fc" id="L212">        final WhiteSpaceReader wsReader = new WhiteSpaceReader(inputStream);</span>

<span class="pc bpc" id="L214" title="2 of 12 branches missed.">        if (identifier2 == PnmConstants.PBM_TEXT_CODE || identifier2 == PnmConstants.PBM_RAW_CODE || identifier2 == PnmConstants.PGM_TEXT_CODE</span>
                || identifier2 == PnmConstants.PGM_RAW_CODE || identifier2 == PnmConstants.PPM_TEXT_CODE || identifier2 == PnmConstants.PPM_RAW_CODE) {

            final int width;
            try {
<span class="fc" id="L219">                width = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="fc" id="L220">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L221">                throw new ImagingException(&quot;Invalid width specified.&quot;, e);</span>
<span class="fc" id="L222">            }</span>
            final int height;
            try {
<span class="fc" id="L225">                height = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="fc" id="L226">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L227">                throw new ImagingException(&quot;Invalid height specified.&quot;, e);</span>
<span class="fc" id="L228">            }</span>

<span class="pc bpc" id="L230" title="3 of 7 branches missed.">            switch (identifier2) {</span>
            case PnmConstants.PBM_TEXT_CODE:
<span class="fc" id="L232">                return new PbmFileInfo(width, height, false);</span>
            case PnmConstants.PBM_RAW_CODE:
<span class="fc" id="L234">                return new PbmFileInfo(width, height, true);</span>
            case PnmConstants.PGM_TEXT_CODE: {
<span class="nc" id="L236">                final int maxgray = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="nc" id="L237">                return new PgmFileInfo(width, height, false, maxgray);</span>
            }
            case PnmConstants.PGM_RAW_CODE: {
<span class="fc" id="L240">                final int maxgray = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="fc" id="L241">                return new PgmFileInfo(width, height, true, maxgray);</span>
            }
            case PnmConstants.PPM_TEXT_CODE: {
<span class="nc" id="L244">                final int max = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="nc" id="L245">                return new PpmFileInfo(width, height, false, max);</span>
            }
            case PnmConstants.PPM_RAW_CODE: {
<span class="fc" id="L248">                final int max = Integer.parseInt(wsReader.readtoWhiteSpace());</span>
<span class="fc" id="L249">                return new PpmFileInfo(width, height, true, max);</span>
            }
            default:
                break;
            }
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        } else if (identifier2 == PnmConstants.PAM_RAW_CODE) {</span>
<span class="fc" id="L255">            int width = -1;</span>
<span class="fc" id="L256">            int height = -1;</span>
<span class="fc" id="L257">            int depth = -1;</span>
<span class="fc" id="L258">            int maxVal = -1;</span>
<span class="fc" id="L259">            final StringBuilder tupleType = new StringBuilder();</span>

            // Advance to next line
<span class="fc" id="L262">            wsReader.readLine();</span>
            String line;
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            while ((line = wsReader.readLine()) != null) {</span>
<span class="fc" id="L265">                line = line.trim();</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                if (line.charAt(0) == '#') {</span>
<span class="nc" id="L267">                    continue;</span>
                }
<span class="fc" id="L269">                final StringTokenizer tokenizer = new StringTokenizer(line, &quot; &quot;, false);</span>
<span class="fc" id="L270">                final String type = tokenizer.nextToken();</span>
<span class="pc bpc" id="L271" title="1 of 7 branches missed.">                switch (type) {</span>
                case TOKEN_WIDTH:
<span class="fc" id="L273">                    width = checkNextTokensAsInt(tokenizer, type);</span>
<span class="fc" id="L274">                    break;</span>
                case TOKEN_HEIGHT:
<span class="fc" id="L276">                    height = checkNextTokensAsInt(tokenizer, type);</span>
<span class="fc" id="L277">                    break;</span>
                case TOKEN_DEPTH:
<span class="fc" id="L279">                    depth = checkNextTokensAsInt(tokenizer, type);</span>
<span class="fc" id="L280">                    break;</span>
                case TOKEN_MAXVAL:
<span class="fc" id="L282">                    maxVal = checkNextTokensAsInt(tokenizer, type);</span>
<span class="fc" id="L283">                    break;</span>
                case TOKEN_TUPLTYPE:
<span class="fc" id="L285">                    tupleType.append(checkNextTokens(tokenizer, type));</span>
<span class="fc" id="L286">                    break;</span>
                case TOKEN_ENDHDR:
                    // consumed &amp; noop
<span class="fc" id="L289">                    break;</span>
                default:
<span class="nc" id="L291">                    throw new ImagingException(&quot;Invalid PAM file header type &quot; + type);</span>
                }
<span class="fc bfc" id="L293" title="All 2 branches covered.">                if (TOKEN_ENDHDR.equals(type)) {</span>
<span class="fc" id="L294">                    break;</span>
                }
<span class="fc" id="L296">            }</span>
<span class="fc" id="L297">            checkFound(width, TOKEN_WIDTH);</span>
<span class="fc" id="L298">            checkFound(height, TOKEN_HEIGHT);</span>
<span class="fc" id="L299">            checkFound(depth, TOKEN_DEPTH);</span>
<span class="fc" id="L300">            checkFound(maxVal, TOKEN_MAXVAL);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            check(tupleType.length() &gt; 0, TOKEN_TUPLTYPE);</span>
<span class="fc" id="L302">            return new PamFileInfo(width, height, depth, maxVal, tupleType.toString());</span>
        }
<span class="nc" id="L304">        throw new ImagingException(&quot;PNM file has invalid prefix byte 2&quot;);</span>
    }

    @Override
    public void writeImage(final BufferedImage src, final OutputStream os, final PnmImagingParameters params) throws ImagingException, IOException {
<span class="fc" id="L309">        PnmWriter writer = null;</span>
<span class="fc" id="L310">        boolean useRawbits = true;</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (params != null) {</span>
<span class="fc" id="L313">            useRawbits = params.isRawBits();</span>

<span class="fc" id="L315">            final ImageFormats subtype = params.getSubtype();</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (subtype != null) {</span>
<span class="nc bnc" id="L317" title="All 5 branches missed.">                switch (subtype) {</span>
                case PBM:
<span class="nc" id="L319">                    writer = new PbmWriter(useRawbits);</span>
<span class="nc" id="L320">                    break;</span>
                case PGM:
<span class="nc" id="L322">                    writer = new PgmWriter(useRawbits);</span>
<span class="nc" id="L323">                    break;</span>
                case PPM:
<span class="nc" id="L325">                    writer = new PpmWriter(useRawbits);</span>
<span class="nc" id="L326">                    break;</span>
                case PAM:
<span class="nc" id="L328">                    writer = new PamWriter();</span>
<span class="nc" id="L329">                    break;</span>
                default:
                    // see null-check below
                    break;
                }
            }
        }

<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (writer == null) {</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">            writer = new PaletteFactory().hasTransparency(src) ? new PamWriter() : new PpmWriter(useRawbits);</span>
        }

<span class="fc" id="L341">        writer.writeImage(src, os, params);</span>
<span class="fc" id="L342">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>