<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Imaging.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Imaging</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.imaging</a> &gt; <span class="el_source">Imaging.java</span></div><h1>Imaging.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.imaging;

import java.awt.Dimension;
import java.awt.color.ICC_Profile;
import java.awt.image.BufferedImage;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.stream.Stream;

import org.apache.commons.imaging.bytesource.ByteSource;
import org.apache.commons.imaging.common.ImageMetadata;
import org.apache.commons.imaging.common.XmpEmbeddable;
import org.apache.commons.imaging.icc.IccProfileInfo;
import org.apache.commons.imaging.icc.IccProfileParser;
import org.apache.commons.imaging.internal.ImageParserFactory;

/**
 * The primary application programming interface (API) to the Imaging library.
 *
 * &lt;h2&gt;Application Notes&lt;/h2&gt;
 *
 * &lt;h3&gt;Using this class&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Almost all of the Apache Commons Imaging library's core functionality can be accessed through the methods provided by this class. The use of the Imaging
 * class is similar to the Java API's ImageIO class, though Imaging supports formats not included in the standard Java API.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * All of methods provided by the Imaging class are declared static.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The Apache Commons Imaging package is a pure Java implementation.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;Format support&lt;/h3&gt;
 *
 * &lt;p&gt;
 * While the Apache Commons Imaging package handles a number of different graphics formats, support for some formats is not yet complete. For the most recent
 * information on support for specific formats, refer to &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format Support&lt;/a&gt; at the main project
 * development web site.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;Optional parameters for image reading and writing&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Many of the operations provided in this class as static calls can be accessed directly using format-specific {@link AbstractImageParser} instances. These
 * static methods are provided for convenience in simple use cases.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;Example code&lt;/h3&gt;
 *
 * &lt;p&gt;
 * See the source of the SampleUsage class and other classes in the org.apache.commons.imaging.examples package for examples.
 * &lt;/p&gt;
 *
 * @see &lt;a href=&quot;https://svn.apache.org/repos/asf/commons/proper/imaging/trunk/src/test/java/org/apache/commons/imaging/examples/SampleUsage.java&quot;&gt;
 *      org.apache.commons.imaging.examples.SampleUsage&lt;/a&gt;
 * @see &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format Support&lt;/a&gt;
 */
public final class Imaging {

<span class="fc" id="L89">    private static final int[] MAGIC_NUMBERS_GIF = { 0x47, 0x49, };</span>
<span class="fc" id="L90">    private static final int[] MAGIC_NUMBERS_PNG = { 0x89, 0x50, };</span>
<span class="fc" id="L91">    private static final int[] MAGIC_NUMBERS_JPEG = { 0xff, 0xd8, };</span>
<span class="fc" id="L92">    private static final int[] MAGIC_NUMBERS_BMP = { 0x42, 0x4d, };</span>
<span class="fc" id="L93">    private static final int[] MAGIC_NUMBERS_TIFF_MOTOROLA = { 0x4D, 0x4D, };</span>
<span class="fc" id="L94">    private static final int[] MAGIC_NUMBERS_TIFF_INTEL = { 0x49, 0x49, };</span>
<span class="fc" id="L95">    private static final int[] MAGIC_NUMBERS_PAM = { 0x50, 0x37, };</span>
<span class="fc" id="L96">    private static final int[] MAGIC_NUMBERS_PSD = { 0x38, 0x42, };</span>
<span class="fc" id="L97">    private static final int[] MAGIC_NUMBERS_PBM_A = { 0x50, 0x31, };</span>
<span class="fc" id="L98">    private static final int[] MAGIC_NUMBERS_PBM_B = { 0x50, 0x34, };</span>
<span class="fc" id="L99">    private static final int[] MAGIC_NUMBERS_PGM_A = { 0x50, 0x32, };</span>
<span class="fc" id="L100">    private static final int[] MAGIC_NUMBERS_PGM_B = { 0x50, 0x35, };</span>
<span class="fc" id="L101">    private static final int[] MAGIC_NUMBERS_PPM_A = { 0x50, 0x33, };</span>
<span class="fc" id="L102">    private static final int[] MAGIC_NUMBERS_PPM_B = { 0x50, 0x36, };</span>
<span class="fc" id="L103">    private static final int[] MAGIC_NUMBERS_JBIG2_1 = { 0x97, 0x4A, };</span>
<span class="fc" id="L104">    private static final int[] MAGIC_NUMBERS_JBIG2_2 = { 0x42, 0x32, };</span>
<span class="fc" id="L105">    private static final int[] MAGIC_NUMBERS_ICNS = { 0x69, 0x63, };</span>
<span class="fc" id="L106">    private static final int[] MAGIC_NUMBERS_DCX = { 0xB1, 0x68, };</span>
<span class="fc" id="L107">    private static final int[] MAGIC_NUMBERS_RGBE = { 0x23, 0x3F, };</span>
<span class="fc" id="L108">    private static final int[] MAGIC_NUMBERS_RIFF_1 = { 0x52, 0x49, };</span>
<span class="fc" id="L109">    private static final int[] MAGIC_NUMBERS_RIFF_2 = { 0x46, 0x46, };</span>
<span class="fc" id="L110">    private static final byte[] MAGIC_NUMBERS_WEBP = { 0x57, 0x45, 0x42, 0x50, };</span>

    private static boolean compareBytePair(final int[] a, final int[] b) {
<span class="pc bpc" id="L113" title="3 of 4 branches missed.">        if (a.length != 2 &amp;&amp; b.length != 2) {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(&quot;Invalid Byte Pair.&quot;);</span>
        }
<span class="fc bfc" id="L116" title="All 4 branches covered.">        return a[0] == b[0] &amp;&amp; a[1] == b[1];</span>
    }

    /**
     * Write the ImageInfo and format-specific information for the image content of the specified byte array to a string.
     *
     * @param bytes A valid array of bytes.
     * @return A valid string.
     * @throws ImagingException In the event that the specified content does not conform to the format of the specific parser implementation.
     * @throws IOException      In the event of unsuccessful read or access operation.
     */
    public static String dumpImageFile(final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L128">        return dumpImageFile(ByteSource.array(bytes));</span>
    }

    private static String dumpImageFile(final ByteSource byteSource) throws ImagingException, IOException {
<span class="nc" id="L132">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="nc" id="L133">        return imageParser.dumpImageFile(byteSource);</span>
    }

    /**
     * Write the ImageInfo and format-specific information for the image content of the specified file to a string.
     *
     * @param file A valid file reference.
     * @return A valid string.
     * @throws ImagingException In the event that the specified content does not conform to the format of the specific parser implementation.
     * @throws IOException      In the event of unsuccessful read or access operation.
     */
    public static String dumpImageFile(final File file) throws ImagingException, IOException {
<span class="nc" id="L145">        return dumpImageFile(ByteSource.file(file));</span>
    }

    /**
     * Gets all images specified by the byte array (some formats may include multiple images within a single data source).
     *
     * @param bytes a valid array of bytes
     * @return A valid (potentially empty) list of BufferedImage objects.
     * @throws ImagingException In the event that the specified content does not conform to the format of the specific parser implementation.
     * @throws IOException      In the event of unsuccessful read or access operation.
     */
    public static List&lt;BufferedImage&gt; getAllBufferedImages(final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L157">        return getAllBufferedImages(ByteSource.array(bytes));</span>
    }

    private static List&lt;BufferedImage&gt; getAllBufferedImages(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L161">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc" id="L162">        return imageParser.getAllBufferedImages(byteSource);</span>
    }

    /**
     * Gets all images specified by the file (some formats may include multiple images within a single data source).
     *
     * @param file A reference to a valid data file.
     * @return A valid (potentially empty) list of BufferedImage objects.
     * @throws ImagingException In the event that the specified content does not conform to the format of the specific parser implementation.
     * @throws IOException      In the event of unsuccessful read or access operation.
     */
    public static List&lt;BufferedImage&gt; getAllBufferedImages(final File file) throws ImagingException, IOException {
<span class="fc" id="L174">        return getAllBufferedImages(ByteSource.file(file));</span>
    }

    /**
     * Gets all images specified by the InputStream (some formats may include multiple images within a single data source).
     *
     * @param is       A valid InputStream
     * @param fileName File name associated with image data (optional).
     * @return A valid (potentially empty) list of BufferedImage objects.
     * @throws ImagingException In the event that the specified content does not conform to the format of the specific parser implementation.
     * @throws IOException      In the event of unsuccessful read or access operation.
     */
    public static List&lt;BufferedImage&gt; getAllBufferedImages(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="nc" id="L187">        return getAllBufferedImages(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Reads the first image from a byte array.
     *
     * &lt;p&gt;
     * For the most recent information on support for specific formats, refer to &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format
     * Support&lt;/a&gt; at the main project development web site. While the Apache Commons Imaging package does not fully support all formats, it can read image
     * info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param bytes a valid array of bytes from which to read data.
     * @return if successful, a valid buffered image
     * @throws ImagingException in the event of a processing error while reading an image (i.e. a format violation, etc.).
     * @throws IOException      in the event of an unrecoverable I/O exception.
     */
    public static BufferedImage getBufferedImage(final byte[] bytes) throws ImagingException, IOException {
<span class="fc" id="L205">        return getBufferedImage(ByteSource.array(bytes));</span>
    }

    private static BufferedImage getBufferedImage(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L209">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc" id="L210">        return imageParser.getBufferedImage(byteSource, null);</span>
    }

    /**
     * Reads the first image from a file.
     *
     * &lt;p&gt;
     * For the most recent information on support for specific formats, refer to &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format
     * Support&lt;/a&gt; at the main project development web site. While the Apache Commons Imaging package does not fully support all formats, it can read image
     * info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param file a valid reference to a file containing image data.
     * @return if successful, a valid buffered image
     * @throws ImagingException in the event of a processing error while reading an image (i.e. a format violation, etc.).
     * @throws IOException      in the event of an unrecoverable I/O exception.
     */
    public static BufferedImage getBufferedImage(final File file) throws ImagingException, IOException {
<span class="fc" id="L228">        return getBufferedImage(ByteSource.file(file));</span>
    }

    /**
     * Reads the first image from an InputStream.
     *
     * &lt;p&gt;
     * For the most recent information on support for specific formats, refer to &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format
     * Support&lt;/a&gt; at the main project development web site. While the Apache Commons Imaging package does not fully support all formats, it can read image
     * info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param is a valid ImageStream from which to read data.
     * @return if successful, a valid buffered image
     * @throws ImagingException in the event of a processing errorfileName while reading an image (i.e. a format violation, etc.).
     * @throws IOException      in the event of an unrecoverable I/O exception.
     */
    public static BufferedImage getBufferedImage(final InputStream is) throws ImagingException, IOException {
<span class="nc" id="L246">        return getBufferedImage(is, null);</span>
    }

    /**
     * Reads the first image from an InputStream.
     *
     * &lt;p&gt;
     * For the most recent information on support for specific formats, refer to &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format
     * Support&lt;/a&gt; at the main project development web site. While the Apache Commons Imaging package does not fully support all formats, it can read image
     * info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param is       a valid ImageStream from which to read data.
     * @param fileName the image file name.
     * @return if successful, a valid buffered image
     * @throws ImagingException in the event of a processing error while reading an image (i.e. a format violation, etc.).
     * @throws IOException      in the event of an unrecoverable I/O exception.
     */
    public static BufferedImage getBufferedImage(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="fc" id="L265">        return getBufferedImage(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Attempts to determine the image format of the specified data and evaluates its format compliance.
     *
     * &lt;p&gt;
     * This method returns a FormatCompliance object which includes information about the data's compliance to a specific format.
     * &lt;/p&gt;
     *
     * @param bytes a valid array of bytes containing image data.
     * @return if successful, a valid FormatCompliance object.
     * @throws ImagingException in the event of unreadable data.
     * @throws IOException      in the event of an unrecoverable I/O condition.
     */
    public static FormatCompliance getFormatCompliance(final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L281">        return getFormatCompliance(ByteSource.array(bytes));</span>
    }

    private static FormatCompliance getFormatCompliance(final ByteSource byteSource) throws ImagingException, IOException {
<span class="nc" id="L285">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="nc" id="L286">        return imageParser.getFormatCompliance(byteSource);</span>
    }

    /**
     * Attempts to determine the image format of the specified data and evaluates its format compliance. This method returns a FormatCompliance object which
     * includes information about the data's compliance to a specific format.
     *
     * @param file valid file containing image data
     * @return if successful, a valid FormatCompliance object.
     * @throws ImagingException in the event of unreadable data.
     * @throws IOException      in the event of an unrecoverable I/O condition.
     */
    public static FormatCompliance getFormatCompliance(final File file) throws ImagingException, IOException {
<span class="nc" id="L299">        return getFormatCompliance(ByteSource.file(file));</span>
    }

    /**
     * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and TIFF images.
     *
     * @param bytes Byte array containing an image file.
     * @return An instance of ICC_Profile or null if the image contains no ICC profile.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ICC_Profile getIccProfile(final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L311">        return getIccProfile(ByteSource.array(bytes));</span>
    }

    protected static ICC_Profile getIccProfile(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L315">        final byte[] bytes = getIccProfileBytes(byteSource);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (bytes == null) {</span>
<span class="fc" id="L317">            return null;</span>
        }

<span class="fc" id="L320">        final IccProfileParser parser = new IccProfileParser();</span>
<span class="fc" id="L321">        final IccProfileInfo info = parser.getIccProfileInfo(bytes);</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L323">            return null;</span>
        }
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (info.isSrgb()) {</span>
<span class="fc" id="L326">            return null;</span>
        }

<span class="fc" id="L329">        return ICC_Profile.getInstance(bytes);</span>
    }

    /**
     * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and TIFF images.
     *
     * @param file File containing image data.
     * @return An instance of ICC_Profile or null if the image contains no ICC profile.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ICC_Profile getIccProfile(final File file) throws ImagingException, IOException {
<span class="fc" id="L341">        return getIccProfile(ByteSource.file(file));</span>
    }

    /**
     * Extracts an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and TIFF images.
     *
     * @param is       InputStream from which to read image data.
     * @param fileName File name associated with image data (optional).
     * @return An instance of ICC_Profile or null if the image contains no ICC profile.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ICC_Profile getIccProfile(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="fc" id="L354">        return getIccProfile(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Extracts the raw bytes of an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and TIFF images.
     *
     * &lt;p&gt;
     * To parse the result use IccProfileParser or ICC_Profile.getInstance(bytes).
     * &lt;/p&gt;
     *
     * @param bytes Byte array containing an image file.
     * @return A byte array.
     * @see IccProfileParser
     * @see ICC_Profile
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static byte[] getIccProfileBytes(final byte[] bytes) throws ImagingException, IOException {
<span class="fc" id="L372">        return getIccProfileBytes(ByteSource.array(bytes));</span>
    }

    private static byte[] getIccProfileBytes(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L376">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc" id="L377">        return imageParser.getIccProfileBytes(byteSource, null);</span>
    }

    /**
     * Extracts the raw bytes of an ICC Profile (if present) from JPEG, PNG, PSD (Photoshop) and TIFF images.
     *
     * &lt;p&gt;
     * To parse the result use IccProfileParser or ICC_Profile.getInstance(bytes).
     * &lt;/p&gt;
     *
     * @param file File containing image data.
     * @return A byte array.
     * @see IccProfileParser
     * @see ICC_Profile
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static byte[] getIccProfileBytes(final File file) throws ImagingException, IOException {
<span class="fc" id="L395">        return getIccProfileBytes(ByteSource.file(file));</span>
    }

    /**
     * Parses the &quot;image info&quot; of an image.
     *
     * &lt;p&gt;
     * &quot;Image info&quot; is a summary of basic information about the image such as: width, height, file format, bit depth, color type, etc.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image metadata.&quot;
     * &lt;/p&gt;
     *
     * @param bytes Byte array containing an image file.
     * @return An instance of ImageInfo.
     * @see ImageInfo
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ImageInfo getImageInfo(final byte[] bytes) throws ImagingException, IOException {
<span class="fc" id="L416">        return getImageInfo(ByteSource.array(bytes));</span>
    }

    private static ImageInfo getImageInfo(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L420">        return ImageParserFactory.getImageParser(byteSource).getImageInfo(byteSource, null);</span>
    }

    /**
     * Parses the &quot;image info&quot; of an image file.
     *
     * &lt;p&gt;
     * &quot;Image info&quot; is a summary of basic information about the image such as: width, height, file format, bit depth, color type, etc.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image metadata.&quot;
     * &lt;/p&gt;
     *
     * @param file File containing image data.
     * @return An instance of ImageInfo.
     * @see ImageInfo
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ImageInfo getImageInfo(final File file) throws ImagingException, IOException {
<span class="fc" id="L441">        return getImageInfo(ByteSource.file(file));</span>
    }

    /**
     * Parses the &quot;image info&quot; of an image.
     *
     * &lt;p&gt;
     * &quot;Image info&quot; is a summary of basic information about the image such as: width, height, file format, bit depth, color type, etc.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image metadata.&quot;
     * &lt;/p&gt;
     *
     * @param is       InputStream from which to read image data.
     * @param fileName File name associated with image data (optional).
     * @return An instance of ImageInfo.
     * @see ImageInfo
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ImageInfo getImageInfo(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="fc" id="L463">        return getImageInfo(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Parses the &quot;image info&quot; of an image.
     *
     * &lt;p&gt;
     * &quot;Image info&quot; is a summary of basic information about the image such as: width, height, file format, bit depth, color type, etc.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image metadata.&quot;
     * &lt;/p&gt;
     *
     * @param fileName String.
     * @param bytes    Byte array containing an image file.
     * @return An instance of ImageInfo.
     * @see ImageInfo
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static ImageInfo getImageInfo(final String fileName, final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L485">        return getImageInfo(ByteSource.array(bytes, fileName));</span>
    }

    /**
     * Determines the width and height of an image.
     *
     * @param bytes Byte array containing an image file.
     * @return The width and height of the image.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static Dimension getImageSize(final byte[] bytes) throws ImagingException, IOException {
<span class="fc" id="L497">        return getImageSize(ByteSource.array(bytes));</span>
    }

    /**
     * Determines the width and height of an image byte source.
     *
     * @param byteSource Byte source data.
     * @return The width and height of the image.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static Dimension getImageSize(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L509">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc" id="L510">        return imageParser.getImageSize(byteSource, null);</span>
    }

    /**
     * Determines the width and height of an image file.
     *
     * @param file File containing image data.
     * @return The width and height of the image.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static Dimension getImageSize(final File file) throws ImagingException, IOException {
<span class="fc" id="L522">        return getImageSize(ByteSource.file(file));</span>
    }

    /**
     * Determines the width and height of an image.
     *
     * @param is       InputStream from which to read image data.
     * @param fileName File name associated with image data (optional).
     * @return The width and height of the image.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static Dimension getImageSize(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="fc" id="L535">        return getImageSize(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Parses the metadata of an image. This metadata depends on the format of the image.
     *
     * &lt;p&gt;
     * JPEG/JFIF files may contain EXIF and/or IPTC metadata. PNG files may contain comments. TIFF files may contain metadata.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The instance of IImageMetadata returned by getMetadata() should be upcast (depending on image format).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image info.&quot;
     * &lt;/p&gt;
     *
     * @param bytes Byte array containing an image file.
     * @return An instance of ImageMetadata.
     * @see org.apache.commons.imaging.common.ImageMetadata
     * @throws ImagingException if it fails to read the image metadata
     * @throws IOException      if it fails to read the image data
     */
    public static ImageMetadata getMetadata(final byte[] bytes) throws ImagingException, IOException {
<span class="fc" id="L560">        return getMetadata(ByteSource.array(bytes));</span>
    }

    private static ImageMetadata getMetadata(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L564">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc" id="L565">        return imageParser.getMetadata(byteSource, null);</span>
    }

    /**
     * Parses the metadata of an image file. This metadata depends on the format of the image.
     *
     * &lt;p&gt;
     * JPEG/JFIF files may contain EXIF and/or IPTC metadata. PNG files may contain comments. TIFF files may contain metadata.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The instance of IImageMetadata returned by getMetadata() should be upcast (depending on image format).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image info.&quot;
     * &lt;/p&gt;
     *
     * @param file File containing image data.
     * @return An instance of IImageMetadata.
     * @see org.apache.commons.imaging.common.ImageMetadata
     * @throws ImagingException if it fails to read the image metadata
     * @throws IOException      if it fails to read the image data
     */
    public static ImageMetadata getMetadata(final File file) throws ImagingException, IOException {
<span class="fc" id="L590">        return getMetadata(ByteSource.file(file));</span>
    }

    /**
     * Parses the metadata of an image file. This metadata depends on the format of the image.
     *
     * &lt;p&gt;
     * JPEG/JFIF files may contain EXIF and/or IPTC metadata. PNG files may contain comments. TIFF files may contain metadata.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The instance of IImageMetadata returned by getMetadata() should be upcast (depending on image format).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Not to be confused with &quot;image info.&quot;
     * &lt;/p&gt;
     *
     * @param is       InputStream from which to read image data.
     * @param fileName File name associated with image data (optional).
     * @return An instance of IImageMetadata.
     * @see org.apache.commons.imaging.common.ImageMetadata
     * @throws ImagingException if it fails to read the image metadata
     * @throws IOException      if it fails to read the image data
     */
    public static ImageMetadata getMetadata(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="fc" id="L616">        return getMetadata(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Extracts the embedded XML metadata as an XML string.
     *
     * @param bytes Byte array containing an image file.
     * @return Xmp Xml as String, if present. Otherwise, returns null.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static String getXmpXml(final byte[] bytes) throws ImagingException, IOException {
<span class="nc" id="L628">        return getXmpXml(ByteSource.array(bytes));</span>
    }

    /**
     * Extracts the embedded XML metadata as an XML string.
     *
     * @param byteSource File containing image data.
     * @return Xmp Xml as String, if present. Otherwise, returns null.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static String getXmpXml(final ByteSource byteSource) throws ImagingException, IOException {
<span class="fc" id="L640">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(byteSource);</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">        if (imageParser instanceof XmpEmbeddable) {</span>
<span class="fc" id="L642">            return ((XmpEmbeddable&lt;?&gt;) imageParser).getXmpXml(byteSource, null);</span>
        }
<span class="fc" id="L644">        return null;</span>
    }

    /**
     * Extracts the embedded XML metadata as an XML string.
     *
     * @param file File containing image data.
     * @return Xmp Xml as String, if present. Otherwise, returns null.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static String getXmpXml(final File file) throws ImagingException, IOException {
<span class="fc" id="L656">        return getXmpXml(ByteSource.file(file));</span>
    }

    /**
     * Extracts the embedded XML metadata as an XML string.
     *
     * @param is       InputStream from which to read image data.
     * @param fileName File name associated with image data (optional).
     * @return Xmp Xml as String, if present. Otherwise, returns null.
     * @throws ImagingException if it fails to parse the image
     * @throws IOException      if it fails to read the image data
     */
    public static String getXmpXml(final InputStream is, final String fileName) throws ImagingException, IOException {
<span class="nc" id="L669">        return getXmpXml(ByteSource.inputStream(is, fileName));</span>
    }

    /**
     * Attempts to determine the image format of a file based on its &quot;magic numbers,&quot; the first bytes of the data.
     *
     * &lt;p&gt;
     * Many graphics format specify identifying byte values that appear at the beginning of the data file. This method checks for such identifying elements and
     * returns a ImageFormat enumeration indicating what it detects. Note that this method can return &quot;false positives&quot; in cases where non-image files begin
     * with the specified byte values.
     * &lt;/p&gt;
     *
     * @param bytes Byte array containing an image file.
     * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be determined.
     * @throws IOException in the event of an unrecoverable I/O condition.
     */
    public static ImageFormat guessFormat(final byte[] bytes) throws IOException {
<span class="fc" id="L686">        return guessFormat(ByteSource.array(bytes));</span>
    }

    /**
     * Attempts to determine the image format of a file based on its &quot;magic numbers,&quot; the first bytes of the data.
     *
     * &lt;p&gt;
     * Many graphics formats specify identifying byte values that appear at the beginning of the data file. This method checks for such identifying elements and
     * returns a ImageFormat enumeration indicating what it detects. Note that this method can return &quot;false positives&quot; in cases where non-image files begin
     * with the specified byte values.
     * &lt;/p&gt;
     *
     * @param byteSource a valid ByteSource object potentially supplying data for an image.
     * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be determined.
     * @throws IllegalArgumentException in the event of an unsuccessful attempt to read the image data
     * @throws IOException              in the event of an unrecoverable I/O condition.
     */
    public static ImageFormat guessFormat(final ByteSource byteSource) throws IOException {
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (byteSource == null) {</span>
<span class="nc" id="L705">            return ImageFormats.UNKNOWN;</span>
        }

<span class="fc" id="L708">        try (InputStream is = byteSource.getInputStream()) {</span>
<span class="fc" id="L709">            final int i1 = is.read();</span>
<span class="fc" id="L710">            final int i2 = is.read();</span>
<span class="pc bpc" id="L711" title="2 of 4 branches missed.">            if (i1 &lt; 0 || i2 &lt; 0) {</span>
<span class="nc" id="L712">                throw new IllegalArgumentException(&quot;Couldn't read magic numbers to guess format.&quot;);</span>
            }

<span class="fc" id="L715">            final int b1 = i1 &amp; 0xff;</span>
<span class="fc" id="L716">            final int b2 = i2 &amp; 0xff;</span>
<span class="fc" id="L717">            final int[] bytePair = { b1, b2, };</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_GIF, bytePair)) {</span>
<span class="fc" id="L720">                return ImageFormats.GIF;</span>
                // } else if (b1 == 0x00 &amp;&amp; b2 == 0x00) // too similar to TGA
                // {
                // return ImageFormat.IMAGE_FORMAT_ICO;
            }
<span class="fc bfc" id="L725" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PNG, bytePair)) {</span>
<span class="fc" id="L726">                return ImageFormats.PNG;</span>
            }
<span class="fc bfc" id="L728" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_JPEG, bytePair)) {</span>
<span class="fc" id="L729">                return ImageFormats.JPEG;</span>
            }
<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_BMP, bytePair)) {</span>
<span class="fc" id="L732">                return ImageFormats.BMP;</span>
            }
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_TIFF_MOTOROLA, bytePair)) {</span>
<span class="fc" id="L735">                return ImageFormats.TIFF;</span>
            }
<span class="fc bfc" id="L737" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_TIFF_INTEL, bytePair)) {</span>
<span class="fc" id="L738">                return ImageFormats.TIFF;</span>
            }
<span class="fc bfc" id="L740" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PSD, bytePair)) {</span>
<span class="fc" id="L741">                return ImageFormats.PSD;</span>
            }
<span class="fc bfc" id="L743" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PAM, bytePair)) {</span>
<span class="fc" id="L744">                return ImageFormats.PAM;</span>
            }
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">            if (compareBytePair(MAGIC_NUMBERS_PBM_A, bytePair)) {</span>
<span class="nc" id="L747">                return ImageFormats.PBM;</span>
            }
<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PBM_B, bytePair)) {</span>
<span class="fc" id="L750">                return ImageFormats.PBM;</span>
            }
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">            if (compareBytePair(MAGIC_NUMBERS_PGM_A, bytePair)) {</span>
<span class="nc" id="L753">                return ImageFormats.PGM;</span>
            }
<span class="fc bfc" id="L755" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PGM_B, bytePair)) {</span>
<span class="fc" id="L756">                return ImageFormats.PGM;</span>
            }
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            if (compareBytePair(MAGIC_NUMBERS_PPM_A, bytePair)) {</span>
<span class="nc" id="L759">                return ImageFormats.PPM;</span>
            }
<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (compareBytePair(MAGIC_NUMBERS_PPM_B, bytePair)) {</span>
<span class="fc" id="L762">                return ImageFormats.PPM;</span>
            }
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">            if (compareBytePair(MAGIC_NUMBERS_JBIG2_1, bytePair)) {</span>
<span class="nc" id="L765">                final int i3 = is.read();</span>
<span class="nc" id="L766">                final int i4 = is.read();</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">                if (i3 &lt; 0 || i4 &lt; 0) {</span>
<span class="nc" id="L768">                    throw new IllegalArgumentException(&quot;Couldn't read magic numbers to guess format.&quot;);</span>
                }

<span class="nc" id="L771">                final int b3 = i3 &amp; 0xff;</span>
<span class="nc" id="L772">                final int b4 = i4 &amp; 0xff;</span>
<span class="nc" id="L773">                final int[] bytePair2 = { b3, b4, };</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (compareBytePair(MAGIC_NUMBERS_JBIG2_2, bytePair2)) {</span>
<span class="nc" id="L775">                    return ImageFormats.JBIG2;</span>
                }
<span class="pc bfc" id="L777" title="All 2 branches covered.">            } else if (compareBytePair(MAGIC_NUMBERS_ICNS, bytePair)) {</span>
<span class="fc" id="L778">                return ImageFormats.ICNS;</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            } else if (compareBytePair(MAGIC_NUMBERS_DCX, bytePair)) {</span>
<span class="fc" id="L780">                return ImageFormats.DCX;</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">            } else if (compareBytePair(MAGIC_NUMBERS_RGBE, bytePair)) {</span>
<span class="fc" id="L782">                return ImageFormats.RGBE;</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            } else if (compareBytePair(MAGIC_NUMBERS_RIFF_1, bytePair)) {</span>
<span class="fc" id="L784">                final int i3 = is.read();</span>
<span class="fc" id="L785">                final int i4 = is.read();</span>
<span class="pc bpc" id="L786" title="2 of 4 branches missed.">                if (i3 &lt; 0 || i4 &lt; 0) {</span>
<span class="nc" id="L787">                    throw new IllegalArgumentException(&quot;Couldn't read magic numbers to guess format.&quot;);</span>
                }

<span class="fc" id="L790">                final int b3 = i3 &amp; 0xff;</span>
<span class="fc" id="L791">                final int b4 = i4 &amp; 0xff;</span>
<span class="fc" id="L792">                final int[] bytePair2 = { b3, b4, };</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">                if (compareBytePair(MAGIC_NUMBERS_RIFF_2, bytePair2)) {</span>
<span class="fc" id="L794">                    final byte[] bytes = new byte[4];</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">                    if (is.read(bytes) &lt; 4) { // Skip file size</span>
<span class="nc" id="L796">                        throw new IllegalArgumentException(&quot;Couldn't read magic numbers to guess format.&quot;);</span>
                    }

<span class="pc bpc" id="L799" title="2 of 4 branches missed.">                    if (is.read(bytes) == 4 &amp;&amp; Arrays.equals(MAGIC_NUMBERS_WEBP, bytes)) {</span>
<span class="fc" id="L800">                        return ImageFormats.WEBP;</span>
                    }
                }
            }
<span class="fc" id="L804">            return Stream.of(ImageFormats.values()).filter(imageFormat -&gt; Stream.of(imageFormat.getExtensions()).anyMatch(extension -&gt; {</span>
<span class="fc" id="L805">                final String fileName = byteSource.getFileName();</span>
<span class="pc bpc" id="L806" title="1 of 4 branches missed.">                if (fileName == null || fileName.trim().isEmpty()) {</span>
<span class="fc" id="L807">                    return false;</span>
                }
<span class="fc" id="L809">                final String fileExtension = fileName.substring(fileName.lastIndexOf('.') + 1);</span>
<span class="pc bpc" id="L810" title="2 of 6 branches missed.">                return extension != null &amp;&amp; !extension.trim().isEmpty() &amp;&amp; fileExtension.equalsIgnoreCase(extension);</span>
<span class="fc" id="L811">            })).findFirst().orElse(ImageFormats.UNKNOWN);</span>
<span class="pc bpc" id="L812" title="23 of 38 branches missed.">        }</span>
    }

    /**
     * Attempts to determine the image format of a file based on its &quot;magic numbers,&quot; the first bytes of the data.
     *
     * &lt;p&gt;
     * Many graphics formats specify identifying byte values that appear at the beginning of the data file. This method checks for such identifying elements and
     * returns a ImageFormat enumeration indicating what it detects. Note that this method can return &quot;false positives&quot; in cases where non-image files begin
     * with the specified byte values.
     * &lt;/p&gt;
     *
     * @param file File containing image data.
     * @return An ImageFormat, such as ImageFormat.IMAGE_FORMAT_JPEG. Returns ImageFormat.IMAGE_FORMAT_UNKNOWN if the image type cannot be determined.
     * @throws IOException in the event of an unrecoverable I/O condition.
     */
    public static ImageFormat guessFormat(final File file) throws IOException {
<span class="fc" id="L829">        return guessFormat(ByteSource.file(file));</span>
    }

    /**
     * Attempts to determine if a file contains an image recorded in a supported graphics format based on its file-name extension (for example &quot;&amp;#46;jpg&quot;,
     * &quot;&amp;#46;gif&quot;, &quot;&amp;#46;png&quot;, etc&amp;#46;).
     *
     * @param file A valid File object providing a reference to a file that may contain an image.
     * @return true if the file-name includes a supported image format file extension; otherwise, false.
     */
    public static boolean hasImageFileExtension(final File file) {
<span class="pc bpc" id="L840" title="2 of 4 branches missed.">        if (file == null || !file.isFile()) {</span>
<span class="nc" id="L841">            return false;</span>
        }
<span class="fc" id="L843">        return hasImageFileExtension(file.getName());</span>
    }

    /**
     * Attempts to determine if a file contains an image recorded in a supported graphics format based on its file-name extension (for example &quot;&amp;#46;jpg&quot;,
     * &quot;&amp;#46;gif&quot;, &quot;&amp;#46;png&quot;, etc&amp;#46;).
     *
     * @param fileName A valid string representing name of file which may contain an image.
     * @return true if the file name has an image format file extension.
     */
    public static boolean hasImageFileExtension(final String fileName) {
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if (fileName == null) {</span>
<span class="nc" id="L855">            return false;</span>
        }

<span class="fc" id="L858">        final String normalizedFileName = fileName.toLowerCase(Locale.ROOT);</span>

<span class="fc bfc" id="L860" title="All 2 branches covered.">        for (final AbstractImageParser&lt;?&gt; imageParser : AbstractImageParser.getAllImageParsers()) {</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">            for (final String extension : imageParser.getAcceptedExtensions()) {</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                if (normalizedFileName.endsWith(extension.toLowerCase(Locale.ROOT))) {</span>
<span class="fc" id="L863">                    return true;</span>
                }
            }
<span class="fc" id="L866">        }</span>

<span class="fc" id="L868">        return false;</span>
    }

    /**
     * Writes the content of a BufferedImage to a file using the specified image format.
     *
     * &lt;p&gt;
     * Image writing is not supported for all graphics formats. For the most recent information on support for specific formats, refer to
     * &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format Support&lt;/a&gt; at the main project development web site. While the Apache Commons
     * Imaging package does not fully support all formats, it can read image info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param src    a valid BufferedImage object
     * @param file   the file to which the output image is to be written
     * @param format the format in which the output image is to be written
     * @throws ImagingException in the event of a format violation, unsupported image format, etc.
     * @throws IOException      in the event of an unrecoverable I/O exception.
     * @see ImagingConstants
     */
    public static void writeImage(final BufferedImage src, final File file, final ImageFormat format) throws ImagingException, IOException {
<span class="fc" id="L888">        try (FileOutputStream fos = new FileOutputStream(file);</span>
<span class="fc" id="L889">                BufferedOutputStream os = new BufferedOutputStream(fos)) {</span>
<span class="fc" id="L890">            writeImage(src, os, format);</span>
        }
<span class="fc" id="L892">    }</span>

    /**
     * Writes the content of a BufferedImage to an OutputStream using the specified image format.
     *
     * &lt;p&gt;
     * Image writing is not supported for all graphics formats. For the most recent information on support for specific formats, refer to
     * &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format Support&lt;/a&gt; at the main project development web site. While the Apache Commons
     * Imaging package does not fully support all formats, it can read image info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param src          a valid BufferedImage object
     * @param outputStream the OutputStream to which the output image is to be written
     * @param format       the format in which the output image is to be written
     * @throws ImagingException in the event of a format violation, unsupported image format, etc.
     * @throws IOException      in the event of an unrecoverable I/O exception.
     * @see ImagingConstants
     */
    public static void writeImage(final BufferedImage src, final OutputStream outputStream, final ImageFormat format) throws ImagingException, IOException {
<span class="fc" id="L911">        Objects.requireNonNull(src, &quot;src&quot;);</span>
<span class="fc" id="L912">        Objects.requireNonNull(outputStream, &quot;outputStream&quot;);</span>
<span class="fc" id="L913">        Objects.requireNonNull(format, &quot;format&quot;);</span>

<span class="fc" id="L915">        final AbstractImageParser&lt;?&gt; imageParser = ImageParserFactory.getImageParser(format);</span>
<span class="fc" id="L916">        imageParser.writeImage(src, outputStream, null);</span>
<span class="fc" id="L917">    }</span>

    /**
     * Writes the content of a BufferedImage to a byte array using the specified image format.
     *
     * &lt;p&gt;
     * Image writing is not supported for all graphics formats. For the most recent information on support for specific formats, refer to
     * &lt;a href=&quot;https://commons.apache.org/imaging/formatsupport.html&quot;&gt;Format Support&lt;/a&gt; at the main project development web site. While the Apache Commons
     * Imaging package does not fully support all formats, it can read image info, metadata and ICC profiles from all image formats that provide this data.
     * &lt;/p&gt;
     *
     * @param src    a valid BufferedImage object
     * @param format the format in which the output image is to be written
     * @return if successful, a valid array of bytes.
     * @throws ImagingException in the event of a format violation, unsupported image format, etc.
     * @throws IOException      in the event of an unrecoverable I/O exception.
     * @see ImagingConstants
     */
    public static byte[] writeImageToBytes(final BufferedImage src, final ImageFormat format) throws ImagingException, IOException {
<span class="fc" id="L936">        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {</span>
<span class="fc" id="L937">            writeImage(src, os, format);</span>
<span class="fc" id="L938">            return os.toByteArray();</span>
        }
    }

    private Imaging() {
        // Instances cannot be created
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>