<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PhotometricInterpreterLogLuv.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Imaging</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.imaging.formats.tiff.photometricinterpreters</a> &gt; <span class="el_source">PhotometricInterpreterLogLuv.java</span></div><h1>PhotometricInterpreterLogLuv.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.imaging.formats.tiff.photometricinterpreters;

import java.io.IOException;

import org.apache.commons.imaging.ImagingException;
import org.apache.commons.imaging.common.ImageBuilder;

/**
 * Photometric interpretation Logluv support. Logluv is an encoding for storing data inside TIFF images.
 *
 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Logluv_TIFF&quot;&gt;Logluv TIFF&lt;/a&gt;
 */
public class PhotometricInterpreterLogLuv extends PhotometricInterpreter {

    /**
     * Rgb values (reg-green-blue, as R-G-B, as in the RGB color model).
     */
<span class="fc" id="L34">    static class RgbValues {</span>
        public int r;
        public int g;
        public int b;
    }

    /**
     * Tristimulus color values (red-green-blue, as X-Y-Z, in the CIE XYZ color space).
     */
<span class="fc" id="L43">    static class TristimulusValues {</span>
        public float x;
        public float y;
        public float z;
    }

    public PhotometricInterpreterLogLuv(final int samplesPerPixel, final int[] bitsPerSample, final int predictor, final int width, final int height) {
<span class="fc" id="L50">        super(samplesPerPixel, bitsPerSample, predictor, width, height);</span>
<span class="fc" id="L51">    }</span>

    /**
     * Receives a triplet tristimulus values (CIE XYZ) and then does a CIELAB-CIEXYZ conversion (consult Wikipedia link for formula), where the CIELAB values
     * are used to calculate the tristimulus values of the reference white point.
     *
     * @param tristimulusValues the XYZ tristimulus values
     * @return RGB values
     * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/CIELAB_color_space&quot;&gt;CIELAB color space&lt;/a&gt;
     */
    RgbValues getRgbValues(final TristimulusValues tristimulusValues) {
<span class="fc" id="L62">        final float varX = tristimulusValues.x / 100f; // X = From 0 to ref_X</span>
<span class="fc" id="L63">        final float varY = tristimulusValues.y / 100f; // Y = From 0 to ref_Y</span>
<span class="fc" id="L64">        final float varZ = tristimulusValues.z / 100f; // Z = From 0 to ref_Y</span>

<span class="fc" id="L66">        float varR = varX * 3.2406f + varY * -1.5372f + varZ * -0.4986f;</span>
<span class="fc" id="L67">        float varG = varX * -0.9689f + varY * 1.8758f + varZ * 0.0415f;</span>
<span class="fc" id="L68">        float varB = varX * 0.0557f + varY * -0.2040f + varZ * 1.0570f;</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (varR &gt; 0.0031308) {</span>
<span class="fc" id="L71">            varR = 1.055f * (float) Math.pow(varR, 1 / 2.4) - 0.055f;</span>
        } else {
<span class="fc" id="L73">            varR = 12.92f * varR;</span>
        }
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (varG &gt; 0.0031308) {</span>
<span class="fc" id="L76">            varG = 1.055f * (float) Math.pow(varG, 1 / 2.4) - 0.055f;</span>
        } else {
<span class="fc" id="L78">            varG = 12.92f * varG;</span>
        }

<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (varB &gt; 0.0031308) {</span>
<span class="fc" id="L82">            varB = 1.055f * (float) Math.pow(varB, 1 / 2.4) - 0.055f;</span>
        } else {
<span class="fc" id="L84">            varB = 12.92f * varB;</span>
        }

        // var_R = ((var_R + 0.16561039f) / (3.0152583f + 0.16561039f));
        // var_G = ((var_G + 0.06561642f) / (3.0239854f + 0.06561642f));
        // var_B = ((var_B + 0.19393992f) / (3.1043448f + 0.19393992f));

<span class="fc" id="L91">        final RgbValues values = new RgbValues();</span>
<span class="fc" id="L92">        values.r = (int) (varR * 255f);</span>
<span class="fc" id="L93">        values.g = (int) (varG * 255f);</span>
<span class="fc" id="L94">        values.b = (int) (varB * 255f);</span>
<span class="fc" id="L95">        return values;</span>
    }

    /**
     * Receives a triplet of CIELAB values, and calculates the tristimulus values. The reference white point used here is the equivalent to summer sun and sky.
     *
     * @param cieL lightness from black to white
     * @param cieA lightness from green to red
     * @param cieB lightness from blue to yellow
     * @return tristimulus (X, Y, and Z) values
     * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/CIELAB_color_space&quot;&gt;CIELAB color space&lt;/a&gt;
     * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/White_point&quot;&gt;White point&lt;/a&gt;
     */
    TristimulusValues getTristimulusValues(final int cieL, final int cieA, final int cieB) {
<span class="fc" id="L109">        float varY = (cieL * 100.0f / 255.0f + 16.0f) / 116.0f;</span>
<span class="fc" id="L110">        float varX = cieA / 500.0f + varY;</span>
<span class="fc" id="L111">        float varZ = varY - cieB / 200.0f;</span>

<span class="fc" id="L113">        final float varXCube = (float) Math.pow(varX, 3.0d);</span>
<span class="fc" id="L114">        final float varYCube = (float) Math.pow(varY, 3.0d);</span>
<span class="fc" id="L115">        final float varZCube = (float) Math.pow(varZ, 3.0d);</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (varYCube &gt; 0.008856f) {</span>
<span class="fc" id="L118">            varY = varYCube;</span>
        } else {
<span class="fc" id="L120">            varY = (varY - 16 / 116.0f) / 7.787f;</span>
        }

<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (varXCube &gt; 0.008856f) {</span>
<span class="fc" id="L124">            varX = varXCube;</span>
        } else {
<span class="fc" id="L126">            varX = (varX - 16 / 116.0f) / 7.787f;</span>
        }

<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (varZCube &gt; 0.008856f) {</span>
<span class="fc" id="L130">            varZ = varZCube;</span>
        } else {
<span class="fc" id="L132">            varZ = (varZ - 16 / 116.0f) / 7.787f;</span>
        }

        // These reference values are the relative white points (XYZ) for commons scene types.
        // The chosen values here reflect a scene with Summer Sun and Sky, temperature of 6504 K,
        // X 95.047, Y 100.0, and Z 108.883.
        // See Color Science by Wyszecki and Stiles for more
<span class="fc" id="L139">        final float refX = 95.047f;</span>
<span class="fc" id="L140">        final float refY = 100.000f;</span>
<span class="fc" id="L141">        final float refZ = 108.883f;</span>

<span class="fc" id="L143">        final TristimulusValues values = new TristimulusValues();</span>
<span class="fc" id="L144">        values.x = refX * varX; // ref_X = 95.047 Observer= 2°, Illuminant= D65</span>
<span class="fc" id="L145">        values.y = refY * varY; // ref_Y = 100.000</span>
<span class="fc" id="L146">        values.z = refZ * varZ; // ref_Z = 108.883</span>
<span class="fc" id="L147">        return values;</span>
    }

    @Override
    public void interpretPixel(final ImageBuilder imageBuilder, final int[] samples, final int x, final int y) throws ImagingException, IOException {
<span class="fc bfc" id="L152" title="All 4 branches covered.">        if (samples == null || samples.length != 3) {</span>
<span class="fc" id="L153">            throw new ImagingException(&quot;Invalid length of bits per sample (expected 3).&quot;);</span>
        }

        // CIE illuminants. An illuminant is a theorical source of visible light with a profile.
        // CIE stands for Commission Internationale de l'Eclairage, or International
        // Comission on Illumination.
<span class="fc" id="L159">        final int cieL = samples[0];</span>
<span class="fc" id="L160">        final int cieA = (byte) samples[1];</span>
<span class="fc" id="L161">        final int cieB = (byte) samples[2];</span>

<span class="fc" id="L163">        final TristimulusValues tristimulusValues = getTristimulusValues(cieL, cieA, cieB);</span>

        // ref_X = 95.047 //Observer = 2°, Illuminant = D65
        // ref_Y = 100.000
        // ref_Z = 108.883

<span class="fc" id="L169">        final RgbValues rgbValues = getRgbValues(tristimulusValues);</span>

        // float R = 1.910f * X - 0.532f * Y - 0.288f * Z;
        // float G = -0.985f * X + 1.999f * Y - 0.028f * Z;
        // float B = 0.058f * X - 0.118f * Y + 0.898f * Z;

<span class="fc" id="L175">        final int red = Math.min(255, Math.max(0, rgbValues.r));</span>
<span class="fc" id="L176">        final int green = Math.min(255, Math.max(0, rgbValues.g));</span>
<span class="fc" id="L177">        final int blue = Math.min(255, Math.max(0, rgbValues.b));</span>
<span class="fc" id="L178">        final int alpha = 0xff;</span>
<span class="fc" id="L179">        final int rgb = alpha &lt;&lt; 24 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue &lt;&lt; 0;</span>
<span class="fc" id="L180">        imageBuilder.setRgb(x, y, rgb);</span>

<span class="fc" id="L182">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>